<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Nayan Blog</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://nayan.co/blog/"/>
  <updated>2019-11-26T11:14:16.256Z</updated>
  <id>https://nayan.co/blog/</id>
  
  <author>
    <name>NayanTech</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Text detection in number plates</title>
    <link href="https://nayan.co/blog/2019/11/26/Text-detection-in-number-plates/"/>
    <id>https://nayan.co/blog/2019/11/26/Text-detection-in-number-plates/</id>
    <published>2019-11-26T15:21:29.000Z</published>
    <updated>2019-11-26T11:14:16.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Text-detection-in-number-plates"><a href="#Text-detection-in-number-plates" class="headerlink" title="Text detection in number plates"></a>Text detection in number plates</h1><p>One of the vital modules in the optical character recognition(OCR) pipeline is text detectionand segmentation which is also called text localization. In this post, we will apply variedpreprocessing techniques to the input image and find out how to localize text in theenhanced image, so that we can feed the segments to our text recognition network.</p><h2 id="Image-Preprocessing"><a href="#Image-Preprocessing" class="headerlink" title="Image Preprocessing"></a>Image Preprocessing</h2><p>Sometimes images can be distorted, noisy and other problems that can scale back the OCRaccuracy. To make a better OCR pipeline, we need to do some image preprocessing.</p><ul><li>Grayscale the image: Generally you will get an image which is having 3channels(color images), we need to convert this image into a grayscale form whichcontains only one channel. We can also process images with three channels but itonly increases the complexity of the model and increases the processing time.OpenCV provides a built-in function that can do it for you.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line">grayscale_image = cv2.cvtColor(image, cv2.COLOR_BRG2GRAY)</span><br></pre></td></tr></table></figure><p>Or you can convert the image to grayscale while reading the image.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#opencv reads image in BGR format</span><br><span class="line">graysacle_image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)</span><br></pre></td></tr></table></figure><ul><li>Noise reduction: Images come with various types of noises. OpenCV provides a lot ofnoise reduction function. I am using the Non-local Means Denoising algorithm.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">denoised_image = cv2.fastNlMeansDenoising(grayscale_img, None, 10, 7, 21)</span><br></pre></td></tr></table></figure><img src="/blog/2019/11/26/Text-detection-in-number-plates/Figure_2.png" class="" title="Denoising"><ul><li>Contrast adjustment: Sometimes we have low contrast images. This makes it difficultto separate text from the image background. We need high contrast text images forthe localization process. We can increase image contrast using Contrast LimitedAdaptive Histogram Equalization (CLAHE) among many other contrast enhancementmethods provided by skimage.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from  skimage import exposure</span><br><span class="line">contrast_enhanced_image = exposure.equalize_adapthist(denoised, clip_limit=0.03)</span><br></pre></td></tr></table></figure><img src="/blog/2019/11/26/Text-detection-in-number-plates/Figure_3.png" class="" title="Contrast Adjustment"><p>So now we are done with image preprocessing let us move on to the second part, textlocalization.</p><h2 id="Text-Localization"><a href="#Text-Localization" class="headerlink" title="Text Localization"></a>Text Localization</h2><p>In this part, we will see how to detect a large number of text region candidates andprogressively removes those less likely to contain text. Using the MSER feature descriptor tofind text candidates in the image. It works well for text because the consistent color and highcontrast of text lead to stable intensity profiles.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#constructor for MSER detector</span><br><span class="line">mser = cv2.MSER_create()</span><br><span class="line">regions, mser_bboxes = mser.detectRegions(contrast_enhance_image)</span><br></pre></td></tr></table></figure><p>Along with the text MSER picked up many other stable regions that are not text. Now, thegeometric properties of text can be used to filter out non-text regions using simplethresholds.</p><p>Before moving on with the filtering process, let’s write some functions to display the results ina comprehensible manner.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">#display images</span><br><span class="line">def pltShow(*images):</span><br><span class="line">    #count number of images to show</span><br><span class="line">    count = len(images)</span><br><span class="line">    #three images per columnn</span><br><span class="line">    Row = np.ceil(count / 3.)</span><br><span class="line">    for i in range(count):</span><br><span class="line">        plt.subplot(nRow, 3, i+1)</span><br><span class="line">        if len(images[i][0], cmap=’gray’)</span><br><span class="line">            plt.imshow(images[i][0], cmap=’gray’)</span><br><span class="line">        else:</span><br><span class="line">            plt.imshow(images[i][0])</span><br><span class="line">        #remove x-y axis from subplots</span><br><span class="line">        plt.xticks([])</span><br><span class="line">        plt.yticks([])</span><br><span class="line">        plt.title(images[i][1])</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">#color each MSER region in image</span><br><span class="line">def colorRegion(image_like_arr, region):</span><br><span class="line">    image_like_arr[region[:, 1], region[:, 0], 0] = np.random.randint(low=100, high=256)</span><br><span class="line">    image_like_arr[region[:, 1], region[:, 0], 1] = np.random.randint(low=100, high=256)</span><br><span class="line">    image_like_arr[region[:, 1], region[:, 0], 2] = np.random.randint(low=100, high=256)</span><br><span class="line"></span><br><span class="line">    return image</span><br></pre></td></tr></table></figure><p>The geometric properties we are going to use to discriminate between text and non-textregion are:</p><ul><li>Region area</li><li>Region perimeter</li><li>Aspect ratio</li><li>Occupancy</li><li>Compactness</li></ul><p>We will apply simple thresholds over these parameters to eliminate non-text regions. Firstlet’s write method to compute these parameters.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#values for the parameters</span><br><span class="line">AREA_LIM = 2.0e-4</span><br><span class="line">PERIMETER_LIM = 1e-4</span><br><span class="line">ASPECT_RATIO_LIM = 5.0</span><br><span class="line">OCCUPATION_LIM = (0.23, 0.90)</span><br><span class="line">COMPACTNESS_LIM = (3e-3, 1e-1)</span><br><span class="line"></span><br><span class="line">def getRegionShape(self, region): </span><br><span class="line">    return (max(region[:, 1]) - min(region[:, 1]), max(region[:, 0]) - min(region[:, 0]))</span><br><span class="line">    </span><br><span class="line">#compute area</span><br><span class="line">def getRegionArea(region):</span><br><span class="line">    return len(list(region))</span><br><span class="line"></span><br><span class="line">#compute perimeter</span><br><span class="line">def getRegionPerimeter(image, region):</span><br><span class="line">    #get top-left coordinate, width and height of the box enclosing the region</span><br><span class="line">    x, y, w, h = cv2.boundingRect(region)</span><br><span class="line">    return len(np.where(image[y:y+h, x:x+w] != 0)[0]))</span><br><span class="line">    </span><br><span class="line">#compute aspect ratio</span><br><span class="line">def getAspectRatio(region):    </span><br><span class="line">    return (1.0 * max(getRegionShape(region))) / (min(getRegionShape(region)) + 1e-4)</span><br><span class="line"></span><br><span class="line">#compute area occupied by the region area in the shape</span><br><span class="line">def getOccupyRate(region):</span><br><span class="line">    return (1.0 * getRegionArea(region)) / (getRegionShape(region)[0] *  \getRegionShape(region)[1] + 1.0e-10)</span><br><span class="line">    </span><br><span class="line">#compute compactness of the regio</span><br><span class="line">ndef getCompactness(region):    </span><br><span class="line">    return (1.0 * getRegionArea(region)) / (1.0 * getRegionPerimeter(region) ** 2)</span><br></pre></td></tr></table></figure><p>Now apply these methods to filter out text regions  as follows:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#total number of MSER regions</span><br><span class="line">n1 = len(regions)</span><br><span class="line">bboxes=[]</span><br><span class="line">for i, region in enumerate(regions):</span><br><span class="line">    self.colorRegion(res, region)</span><br><span class="line">    if self.getRegionArea(region) &gt; self.grayImg.shape[0] * self.grayImg.shape[1] * AREA_LIM:</span><br><span class="line">       #number of regions meeting the area criteria</span><br><span class="line">    n2 += 1</span><br><span class="line">    self.colorRegion(res2, region)</span><br><span class="line"></span><br><span class="line">    if self.getRegionPerimeter(region) &gt; 2 * (self.grayImg.shape[0] + \</span><br><span class="line">        self.grayImg.shape[1]) * PERIMETER_LIM:</span><br><span class="line">   #number of regions meeting the perimeter criteria</span><br><span class="line">        n3 += 1</span><br><span class="line">   self.colorRegion(res3, region)</span><br><span class="line"> </span><br><span class="line">        if self.getAspectRatio(region) &lt; ASPECT_RATIO_LIM:</span><br><span class="line">   #number of regions meeting the aspect ratio criteria </span><br><span class="line">                n4 += 1</span><br><span class="line">   self.colorRegion(res4, region)</span><br><span class="line"></span><br><span class="line">   if (self.getOccupyRate(region) &gt; OCCUPATION_LIM[0]) and \ (self.getOccupyRate(region) &lt; OCCUPATION_LIM[1]):</span><br><span class="line">   n5 += 1</span><br><span class="line">   self.colorRegion(res5, region)</span><br><span class="line"></span><br><span class="line">   if (self.getCompactness(region) &gt; \COMPACTNESS_LIM[0]) and \(self.getCompactness(region) &lt; \COMPACTNESS_LIM[1]):</span><br><span class="line">   #final number of regions left </span><br><span class="line">                        n6 += 1</span><br><span class="line">   self.colorRegion(res6, region)</span><br><span class="line">                        bboxes.append(mser_bboxes[i])</span><br></pre></td></tr></table></figure><p>After eliminating non-text regions, I draw bounding boxes on the remaining regions andvoila, we have successfully detected and segmented the characters on the number plate.<br>Note: Apply NMS to remove overlapping bounding boxes.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for bbox in bboxes:</span><br><span class="line">   cv2.rectangle(img,(bbox[0]-1,bbox[1]-1),(bbox[0]+bbox[2]+1,box[1]+bbox[3]+1),(255,0,0), 1)</span><br></pre></td></tr></table></figure><p>Enough coding. Let’s see some results.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pltShow(&quot;MSER Result Analysis&quot;, \</span><br><span class="line">      (self.img, &quot;Image&quot;), \</span><br><span class="line">      (self.cannyImg, &quot;Canny&quot;), \</span><br><span class="line">      (res, &quot;MSER,(&#123;&#125; regions)&quot;.format(n1)), \</span><br><span class="line">      (res2, &quot;Area=&#123;&#125;,(&#123;&#125; regions)&quot;.format(config.mser_areaLimit, n2)), \</span><br><span class="line">      (res3, &quot;Perimeter=&#123;&#125;,(&#123;&#125; regions)&quot;.format(config.mser_perimeterLimit, n3)), \</span><br><span class="line">      (res4, &quot;Aspect Ratio=&#123;&#125;,(&#123;&#125; regions)&quot;.format(config.mser_aspectRatioLimit, n4)), \</span><br><span class="line">      (res5, &quot;Occupation=&#123;&#125;,(&#123;&#125; regions)&quot;.format(config.mser_occupationLimit, n5)), \</span><br><span class="line">      (res6, &quot;Compactness=&#123;&#125;,(&#123;&#125; regions)&quot;.format(config.mser_compactnessLimit, n6)), \</span><br><span class="line">      (boxRes, &quot;Segmented Image&quot;) \</span><br><span class="line">   )</span><br></pre></td></tr></table></figure><img src="/blog/2019/11/26/Text-detection-in-number-plates/Figure_1.png" class="" title="MSER Result Analysis"><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>In this post, we covered the various image preprocessing techniques and learned about howto perform text localization on number plates.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Text-detection-in-number-plates&quot;&gt;&lt;a href=&quot;#Text-detection-in-number-plates&quot; class=&quot;headerlink&quot; title=&quot;Text detection in number plate
      
    
    </summary>
    
    
      <category term="AI" scheme="https://nayan.co/blog/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>Detecting Lanes using Deep Neural Networks</title>
    <link href="https://nayan.co/blog/2019/11/26/Detecting-Lanes-using-Deep-Neural-Networks/"/>
    <id>https://nayan.co/blog/2019/11/26/Detecting-Lanes-using-Deep-Neural-Networks/</id>
    <published>2019-11-26T11:17:10.000Z</published>
    <updated>2019-11-26T11:14:16.248Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>This post explains how to use deep neural networks to detect highway lanes. Lane markings are the main static component on highways.<strong>They instruct the vehicles to interactively and safely drive on the highways.</strong> Lane detection is also an important task in autonomous driving, which provides localization information to the control of the car. It is also used in <strong>ADAS(Advanced Driver Assistance System)</strong>.</p></blockquote><p>For the task of lane detection, we have two open-source datasets available. One is the Tusimple dataset and the other is the CULane dataset. Let’s have a brief look at one of the datasets.</p><h2 id="Tusimple-Dataset"><a href="#Tusimple-Dataset" class="headerlink" title="Tusimple Dataset"></a>Tusimple Dataset</h2><p>This dataset was released as part of the Tusimple Lane Detection Challenge. It contains 3626 video clips of 1 sec duration each. Each of these video clips contains 20 frames of which, the last frame is annotated. These videos were captured by mounting the cameras on a vehicle dashboard. You can download the dataset from <a href="https://github.com/TuSimple/tusimple-benchmark/issues/3" target="_blank" rel="noopener">here</a>.</p><p>The directory structure looks like the figure below,</p><img src="/blog/2019/11/26/Detecting-Lanes-using-Deep-Neural-Networks/dir_structure.png" class="" title="Dataset directory structure"><p>Each sub-directory contains 20 sequential images of which, the last frame is annotated. label_data_(date).json contains labels in JSON format for the last frame. Each line in the JSON file is a dictionary with key values…</p><p><strong>raw_file</strong>: string type. the file path in the clip</p><p><strong>lanes</strong>: it is a list of list of lanes. Each list corresponds to a lane and each element of the inner list is x-coordinate of ground truth lane.</p><p><strong>h_samples</strong>: it is a list of height values corresponding to the lanes. Each element in this list is y-coordinate of ground truth lane</p><p>In this dataset, at most four lanes are annotated - the two ego lanes (two lane boundaries in which the vehicle is currently located) and the lanes to the right and left of ego lanes. All the lanes are annotated at an equal interval of height, therefore h_samples contain only one list whose elements correspond to y-coordinates for all lists in lanes. For a point in h_samples, if there is no lane at the location, its corresponding x-coordinate has -2. For example, a line in the JSON file looks like :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;lanes&quot;: [</span><br><span class="line">        [-2, -2, -2, -2, 632, 625, 617, 609, 601, 594, 586, 578, 570, 563, 555, 547, 539, 532, 524, 516, 508, 501, 493, 485, 477, 469, 462, 454, 446, 438, 431, 423, 415, 407, 400, 392, 384, 376, 369, 361, 353, 345, 338, 330, 322, 314, 307, 299],</span><br><span class="line">        [-2, -2, -2, -2, 719, 734, 748, 762, 777, 791, 805, 820, 834, 848, 863, 877, 891, 906, 920, 934, 949, 963, 978, 992, 1006, 1021, 1035, 1049, 1064, 1078, 1092, 1107, 1121, 1135, 1150, 1164, 1178, 1193, 1207, 1221, 1236, 1250, 1265, -2, -2, -2, -2, -2],</span><br><span class="line">        [-2, -2, -2, -2, -2, 532, 503, 474, 445, 416, 387, 358, 329, 300, 271, 241, 212, 183, 154, 125, 96, 67, 38, 9, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2],</span><br><span class="line">        [-2, -2, -2, 781, 822, 862, 903, 944, 984, 1025, 1066, 1107, 1147, 1188, 1229, 1269, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2]</span><br><span class="line">       ],</span><br><span class="line">  &quot;h_samples&quot;: [240, 250, 260, 270, 280, 290, 300, 310, 320, 330, 340, 350, 360, 370, 380, 390, 400, 410, 420, 430, 440, 450, 460, 470, 480, 490, 500, 510, 520, 530, 540, 550, 560, 570, 580, 590, 600, 610, 620, 630, 640, 650, 660, 670, 680, 690, 700, 710],</span><br><span class="line">  &quot;raw_file&quot;: &quot;path_to_clip&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It says that there are four lanes in the image, and the first lane starts at (632,280), the second lane starts at (719,280), the third lane starts at (532,290) and the fourth lane starts at (781,270).</p><h2 id="DataSet-Visualization"><a href="#DataSet-Visualization" class="headerlink" title="DataSet Visualization"></a>DataSet Visualization</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># import required packages</span><br><span class="line">import json</span><br><span class="line">import numpy as np</span><br><span class="line">import cv2</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"># read each line of json file</span><br><span class="line">json_gt = [json.loads(line) for line in open(&apos;label_data.json&apos;)]</span><br><span class="line">gt = json_gt[0]</span><br><span class="line">gt_lanes = gt[&apos;lanes&apos;]</span><br><span class="line">y_samples = gt[&apos;h_samples&apos;]</span><br><span class="line">raw_file = gt[&apos;raw_file&apos;]</span><br><span class="line"># see the image</span><br><span class="line">img = cv2.imread(raw_file)</span><br><span class="line">cv2.imshow(&apos;image&apos;,img)</span><br><span class="line">cv2.WaitKey(0)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><img src="/blog/2019/11/26/Detecting-Lanes-using-Deep-Neural-Networks/image_1.jpg" class="" title="Image 1. Raw image from the dataset"><p>Now see the JSON points visualization on the image</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gt_lanes_vis = [[(x, y) for (x, y) in zip(lane, y_samples)</span><br><span class="line">                  if x &gt;= 0] for lane in gt_lanes]</span><br><span class="line">img_vis = img.copy()</span><br><span class="line"></span><br><span class="line">for lane in gt_lanes_vis:</span><br><span class="line">    cv2.polylines(img_vis, np.int32([lane]), isClosed=False,</span><br><span class="line">                   color=(0,255,0), thickness=5)</span><br></pre></td></tr></table></figure><img src="/blog/2019/11/26/Detecting-Lanes-using-Deep-Neural-Networks/image_2.jpg" class="" title="Image 2. Label visualications of image"><p>Now, we have understood the dataset, but we can not pass the above image as a label for the neural network since <strong>grayscale images with values ranging from zero to num_classes -1 are to be passed to the deep convolution neural network to outputs an image containing predicted lanes</strong>. So, we need to generate label images for the JSON files. Label images can be generated using <strong>OpenCV</strong> by drawing lines passing through the points in the JSON file.</p><p>OpenCV has an inbuilt function to draw multiple lines through a set of points. OpenCV’s Polylines method can be used here. First, create a mask of all zeros with height and width equal to the raw file’s height and width using numpy. <strong>The image size can be reduced to maintain lesser computations during training, but do not forget to maintain the same aspect ratio</strong>.</p><h2 id="Generating-Labels"><a href="#Generating-Labels" class="headerlink" title="Generating Labels"></a>Generating Labels</h2><p>The label should be a grayscale image. Generate one label for each clip from the JSON file. First, create a mask of black pixels with a shape similar to the raw_file image from the JSON file. Now, using OpenCV’s polylines method draw lines with different colors (each corresponding to each lane in lanes) on the mask image using the lanes and h_samples from the JSON file. From the three channeled mask image generate a gray scale mask image with values as class numbers. Likewise, create labels for all the images in the JSON file. You can resize the image and its label to a smaller size for lesser computations.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mask = np.zeros_like(img)</span><br><span class="line">colors = [[255,0,0],[0,255,0],[0,0,255],[0,255,255]]</span><br><span class="line">for i in range(len(gt_lanes_vis)):</span><br><span class="line">    cv2.polylines(mask, np.int32([gt_lanes_vis[i]]), isClosed=False,color=colors[i], thickness=5)</span><br><span class="line">!! create grey-scale label image</span><br><span class="line">label = np.zeros((720,1280),dtype = np.uint8)</span><br><span class="line">for i in range(len(colors)):</span><br><span class="line">   label[np.where((mask == colors[i]).all(axis = 2))] = i+1</span><br></pre></td></tr></table></figure><img src="/blog/2019/11/26/Detecting-Lanes-using-Deep-Neural-Networks/image_3.jpg" class="" title="Image 3. Generated mask image"><h2 id="Build-and-Train-Model"><a href="#Build-and-Train-Model" class="headerlink" title="Build and Train Model"></a>Build and Train Model</h2><p>Lane Detection is essentially an image segmentation problem. So I am using the <strong>ERFNET model</strong> for this task, which is efficient and fast. Originally ERFNET was proposed for semantic segmentation problems, but it can also be extended to other image segmentation problems. You can check out for its paper <a href="https://ieeexplore.ieee.org/abstract/document/8063438" target="_blank" rel="noopener">here</a>. It is a CNN with Encoder, Decoder and dilated convolutions along with non-bottleneck residual layers. See Fig.1 for model architecture.</p><img src="/blog/2019/11/26/Detecting-Lanes-using-Deep-Neural-Networks/figure_1.png" class="" title="Figure 1. Model Architecture"><p>Build and create an object of the model. Train it over the dataset created above, for a sufficient number of epochs with Binary Cross Entropy loss or custom loss function which minimizes the per-pixel error. For better memory usage, create a dataset generator and train the model over it. Generators remove the burden of loading all the images into memory (if your dataset is of large size, you should use a generator) which leads to eating up of all memory and the other processes can’t work properly. Fig 2 shows the layers of ERFNET with input and output dimensions.</p><img src="/blog/2019/11/26/Detecting-Lanes-using-Deep-Neural-Networks/figure_2.png" class="" title="Figure 2. Model layers with input and output shapes"><h2 id="Evaluate-Model"><a href="#Evaluate-Model" class="headerlink" title="Evaluate Model"></a>Evaluate Model</h2><p>After training, get the model’s predictions using the code snippet below. I have implemented this in Pytorch. I use the color_lanes method to convert output images from the model (which are two channeled with values as class numbers) to three channeled images. im_seg is the final overlayed image shown in Image 4.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#using pytorch</span><br><span class="line">import torch</span><br><span class="line">from torchvision.transforms import ToTensor</span><br><span class="line">def color_lanes(image, classes, i, color, HEIGHT, WIDTH):</span><br><span class="line">    buffer_c1 = np.zeros((HEIGHT, WIDTH), dtype=np.uint8)</span><br><span class="line">    buffer_c1[classes == i] = color[0]</span><br><span class="line">    image[:, :, 0] += buffer_c1</span><br><span class="line">    buffer_c2 = np.zeros((HEIGHT, WIDTH), dtype=np.uint8)</span><br><span class="line">    buffer_c2[classes == i] = color[1]</span><br><span class="line">    image[:, :, 1] += buffer_c2</span><br><span class="line">    buffer_c3 = np.zeros((HEIGHT, WIDTH), dtype=np.uint8)</span><br><span class="line">    buffer_c3[classes == i] = color[2]</span><br><span class="line">    image[:, :, 2] += buffer_c3</span><br><span class="line">    return image</span><br><span class="line">img = cv2.imread(&apos;images/test.jpg&apos;) </span><br><span class="line">img = cv2.resize(img,(WIDTH, HEIGHT),interpolation = cv2.INETR_CUBIC)</span><br><span class="line">op_transforms = transforms.Compose([transforms.ToTensor()])</span><br><span class="line">device = torch.device(&apos;cuda&apos; if torch.cuda.is_available() else &apos;cpu&apos;)</span><br><span class="line">im_tensor = torch.unsqueeze(op_transforms(img), dim=0)</span><br><span class="line">im_tensor = im_tensor.to(device)</span><br><span class="line">model = ERFNET(5)</span><br><span class="line">model = model.to(device)</span><br><span class="line">model = model.eval()</span><br><span class="line">out = model(im_tensor)</span><br><span class="line">out = out.max(dim=1)[1]</span><br><span class="line">out_np = out.cpu().numpy()[0]</span><br><span class="line">out_viz = np.zeros((HEIGHT, WIDTH, 3))</span><br><span class="line">for i in range(1, NUM_LD_CLASSES):</span><br><span class="line">    rand_c1 = random.randint(1, 255)</span><br><span class="line">    rand_c2 = random.randint(1, 255)</span><br><span class="line">    rand_c3 = random.randint(1, 255)</span><br><span class="line">    out_viz = color_lanes(</span><br><span class="line">            out_viz, out_np,</span><br><span class="line">            i, (rand_c1, rand_c2, rand_c3), HEIGHT, WIDTH)</span><br><span class="line">instance_im = out_viz.astype(np.uint8)</span><br><span class="line">im_seg = cv2.addWeighted(img, 1, instance_im, 1, 0)</span><br></pre></td></tr></table></figure><img src="/blog/2019/11/26/Detecting-Lanes-using-Deep-Neural-Networks/image_4.jpg" class="" title="Image 4. Final predicted image"><p>Thanks for reading it…</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li>ERFNet: Efficient Residual Factorized ConvNet for Real-time Semantic 2. Segmentation.</li><li>Lane Detection and Classification using CNNs.</li><li><a href="https://www.mdpi.com/sensors/sensors-19-00503/article_deploy/html/images/sensors-19-00503-g004.png" target="_blank" rel="noopener">https://www.mdpi.com/sensors/sensors-19-00503/article_deploy/html/images/sensors-19-00503-g004.png</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;This post explains how to use deep neural networks to detect highway lanes. Lane markings are the main static component on h
      
    
    </summary>
    
    
      <category term="AI" scheme="https://nayan.co/blog/categories/AI/"/>
    
    
      <category term="Machine Learning" scheme="https://nayan.co/blog/tags/Machine-Learning/"/>
    
      <category term="Deep Learning" scheme="https://nayan.co/blog/tags/Deep-Learning/"/>
    
      <category term="Lane Detection" scheme="https://nayan.co/blog/tags/Lane-Detection/"/>
    
      <category term="Advance Driver Assistance" scheme="https://nayan.co/blog/tags/Advance-Driver-Assistance/"/>
    
      <category term="Autonomous Driving" scheme="https://nayan.co/blog/tags/Autonomous-Driving/"/>
    
  </entry>
  
</feed>
